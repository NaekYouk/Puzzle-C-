#include "lib.h"		//Подключение заголовочного файла
void shuffle(char *y); //Объявление функций 
void print(char a[4][4]);

int game(){
	system("cls");	//Выводим правила игры и ждём когда пользователь нажмёт клавишу
	puts("Правила игры:");
	puts("Игрок должен собрать все элементы пазла в порядке возрастания.");
	puts("Элементы выстраиваются порядке возрастания 16-ой системы счисления.\n");
	puts("Управления:");
	puts("Управление осуществляется посредством нажатия клавиш клавиатуры:");
	puts("'вверх','вниз','влево','вправо'");
	_getch();
	int i, j, in, jn, k, steps;
	char mas[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', ' ' }, a[4][4], c;
	char *y = &mas[0];	//Объявления сылки на массив для дальнейшего его перемешивания
	srand(time(NULL));
	steps = 0;	//Обнуление количества шагов перед игрой
	shuffle(y);		//Передаём сылку функции перемешивания массива
	for (i = 0; i < 4; i++)		//Записываем в массив 'a' массив 'mas' с уже "перемешанными" элементами
	for (j = 0; j < 4; j++)
		a[i][j] = *(y++);
	print(a);		//Передаём массив 'a' функции вывода массива на экран
	in = 3;			//переменная отвечает за нахождения главного элемента в строке
	jn = 3;			//переменная отвечает за нахождения главного элемента в столбце
	while (TRUE)	//Бесконечный цикл обеспечит постоянное взаимодейтсвие с игроком до момента выхода из него
	{
		if (GetAsyncKeyState(VK_LEFT))		//проверка на нажатие клавиши "влево"
		{
			keybd_event(VK_LEFT, 0, KEYEVENTF_KEYUP, 0);//Отжимаем кнопку
			if (jn != 0){		//проверка условия нахождения главного элемента в пределах столбца
				c = a[in][jn - 1];		//Перемещение элементоа между собой
				a[in][jn - 1] = ' ';
				a[in][jn] = c;
				jn -= 1;		//Изменяем положение главного элемента по столбцу
				++steps;		//наращиваем кол-во шагов
				print(a);
			}

		}
		if (GetAsyncKeyState(VK_RIGHT))		//проверка на нажатие клавиши "вправо"
		{
			keybd_event(VK_RIGHT, 0, KEYEVENTF_KEYUP, 0);//Отжимаем кнопку
			if (jn != 3){		//проверка условия нахождения главного элемента в пределах столбца
				c = a[in][jn + 1];
				a[in][jn + 1] = ' ';
				a[in][jn] = c;
				jn += 1;
				++steps;
				print(a);
			}
		}
		if (GetAsyncKeyState(VK_UP))		//проверка на нажатие клавиши "вверх"
		{
			keybd_event(VK_UP, 0, KEYEVENTF_KEYUP, 0);//Отжимаем кнопку
			if (in != 0){		//проверка условия нахождения главного элемента в пределах строки
				c = a[in - 1][jn];
				a[in - 1][jn] = ' ';
				a[in][jn] = c;
				in -= 1;	//Изменяем положение главного элемента по строке
				++steps;
				print(a);
			}
		}
		if (GetAsyncKeyState(VK_DOWN))		//проверка на нажатие клавиши "вниз"
		{
			keybd_event(VK_DOWN, 0, KEYEVENTF_KEYUP, 0);//Отжимаем кнопку
			if (in != 3){			//проверка условия нахождения главного элемента в пределах строки
				c = a[in + 1][jn];
				a[in + 1][jn] = ' ';
				a[in][jn] = c;
				in += 1;
				++steps;
				print(a);
			}
		}
		if (GetAsyncKeyState(VK_ESCAPE))		//проверка на нажатие клавиши "ESC"
		{
			keybd_event(VK_ESCAPE, 0, KEYEVENTF_KEYUP, 0);		
			return 0;							//возращаемся в главное меню
		}
		if (a[0][0] == '1' && a[0][1] == '2' && a[0][2] == '3' && a[0][3] == '4' && a[1][0] == '5' && a[1][1] == '6' && a[1][2] == '7' && a[1][3] == '8', a[2][0] == '9' && a[2][1] == 'A' && a[2][2] == 'B' && a[2][3] == 'C' && a[3][0] == 'D' && a[3][1] == 'E' && a[3][2] == 'F' && a[3][3] == ' ')		//проверка условия решения
			return (steps);			//Проверка условия сборки пазла и возврат количества шагов
	}
}

void shuffle(char *y){		//Функция пемещивания массива 
	srand(time(NULL));
	for (int i = 15; i >= 1; --i)
	{
		int j = rand() % i;
		if (j != 15 && i != 15){
			char tmp = *(y + j);
			*(y + j) = *(y + i);
			*(y + i) = tmp;
		}
	}
}

void print(char a[4][4]){		//Функция вывода игрового поля на экран
	system("cls");
	for (int i = 0; i < 4; i++){
		printf("\n\n\n");
		for (int j = 0; j < 4; j++)
			printf("  %c  ", a[i][j]);
	}
}